* Functors Redux
We've learned by now how a lot of types (well, type constructors really) are instances of =Functor=, like =[]=, =Maybe=, =Either a= and a =Tree= type that we made on our own.
We saw how we can map functions over them for great good.
In this section, we'll take a look at two more instances of functor, namely =IO= and =(->) r=.

If some value has a type of, say, =IO String=, that means that it's an I/O action that, when performed, will go out into the real world and get some string for us, which it will yield as a result.
We can use =<-= in /do/ syntax to bind that result to a name.
We mentioned that I/O actions are like boxes with little feet that go out and fetch some value from the outside world for us.
We can inspect what they fetched, but after inspecting, we have to wrap the value back in =IO=.
By thinking about thir box with little feet analogy, we can see how =IO= acts like a functor.

Let's see how =IO= is an instance of =Functor=.
When we =fmap= a function over an I/O action, we want to get back an I/O action that does the same thing, but has our function applied over its result value.

#+begin_src haskell
  instance Functor IO where
      fmap f action = do
	  result <- action
	  return (f result)
#+end_src

The result of mapping something over an I/O action will be an I/O action, so right off the bat we use /do/ syntax to glue two actions and make a new one.
In the implementation for =fmap=, we make a new I/O action that first performs the original I/O actio and calls its result =result=. Then, we do =return (f result)=.
=return= is, as you know, a function that makes an I/O action that doesn't do anything but only presents something as its result.
The action that /a do/ block produces will always have the result value of its last action.
That's why we use return to make an I/O action that doesn't really do anything, it just presents =f result= as the result of the new I/O action.

We can play around with it to gain some intuition. It's pretty simple really. Check out this piece of code:
#+begin_src haskell
  main = do line <- getLine
	    let line' = reverse line
	    putStrLn $ "You said " ++ line' ++ "backwards!"
	    putStrLn $ "Yes, you really said " ++ line' ++ "backwards!"
#+end_src

The user is prompted for a line and we give it back to the user, only reversed, Here's how to rewrite this by using =fmap=:
#+begin_src haskell
  main = do line <- fmap reverse getLine
	    putStrLn $ "You said " ++ line ++ " backwards!"
	    putStrLn $ "Yes, you really said " ++ line ++ " backwards!"
#+end_src

If we look at what =fmap='s type would be if it were limited to =IO=, it would be =fmap :: (a -> b) -> IO a -> IO b=.
=fmap= takes a function and an I/O action and returns a new I/O action that's like the old one, except that the function is applied to its contained result.

Another instance of =Functor= that we've been dealing with all along but didn't know was a =Functor= is =(->) r=.
The function type =r -> a= can be rewritten as =(->) r a=, much like we can write =2 + 3= as =(+) 2 3=.
When we look at it as =(->) r a=, we can see =(->)= in a slighty different light, because we see that it's just a type constructor that takes two type parameters, just like =Either=.
But remember, we said that a type constructor has to take exactly one type parameter so that it can be made an instance of =Functor=.
That's why we can't make =(->)= an instance of =Functor=, but if we partially apply it to =(->) r=, it doesn't pose any problems.
If the syntax allowed for type constructors to be partially applied with sections (like we can partially apply =+= by doing =(2+)=, which is the same as =(+) 2=), you could write =(->) r= as =(r ->)=.
How are functions functors? Well, let's take a look at the implementation, which lies in =Control.Monad.Instances=.

#+begin_src haskell
  instance Functor ((->) r) where
      fmap f g = (\x -> f (g x))
#+end_src


First of all, let's think about =fmap='s type. It's =fmap :: (a -> b) -> f a -> f b=.
Now what we'll do is mentally replace all the =f='s, which are the role that our functor instance plays, with =(->) r='s.
We'll do that to see how =fmap= should behave for this particular instance.
We get =fmap :: (a -> b) -> ((->) r a) -> ((->) r b)=. Now what we can do is write the =(->) r a= and =(-> r b)= typee as infix =r -> a= and =r -> b=, like we normally do with functions.
What we get now is =fmap :: (a -> b) -> (r -> a) -> (r -> b)=.
So this type remind us of Function Composition, we pipe the output of =r -> a= into the input of =a -> b= to get a function =r -> b=.

Next up, we're going to look at the *functor laws*. In order for something to be a functor, it should satisfy some laws.
All functors are expected to exhibit certain kinds of functor-like properties and behaviors.
They should reliably behave as things that can be mapped over.

*The first functor law states that if we map the =id= function over a functor, the functor that we get back should be the same as the original functor*.
If we write that a bit more formally. it means that =fmap id = id=.
So essentially, this says that if we do =fmap id= over a functor, it should be the same as just callint =id= in the functor.
Remember, =id= is the identity function, which just returns its parameter unmodified. It can also be written as =\x -> x=.

*The second law says that composing two functions and then mapping the resulting function over a functor should  be the same as first mapping one function over the functor and then mapping the other one.*
Formally written, that means that =fmap (f . g) = fmap f . fmap g=.
Or to write it in another way, for any functor /F/, the following should hold: =fmap (f . g) F = fmap f (fmap g F)=.

 If we can show that some type obeys both functor laws, we can rely on it having the same fundamental behaviors as othes functors when it comes to mapping.
 We can know that when we use =fmap= on it, there won't be anything other than mapping going on behind the scenes and that it will act like a thing that can be mapped over, i.e. a functor.
